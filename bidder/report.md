# PA2: flocking ROS package
# Author: Liam Prevelige 
# COSC69.13, Spring 2021

### Method Description

#### For a multi-robot system to achieve flocking behavior, three simple local behaviors must be implemented: cohesion, separation, and alignment, all of which are implemented discretely in the ```flocking``` node.
#### (1) Cohesion: A callback from ground_truth populates the distance values for the current robot relative to all other robots in the system. If the minimum distance from a robot is greater than a threshold, indiciating the robot should move toward its neighbors, the rest of the ```cohesion()``` method is executed. In this case, once the minimum distance values and positions of other robots are calculated and stored, the method ```cohesion()``` calculates the average position of the robot using the positional values of all robots in the system. Then, the angle between the current heading of the robot and the heading it needs to achieve, in order to reach the average position, is calculated. Based on this value, the best direction of rotation is determined (clockwise/counterclockwise) and continues to rotate until the desired heading is achieved. Note that the average position may change over the course of this rotation, so the desired heading is updated for each incremental rotation the robot executes.
#### (2) Separation: Like ```cohesion()``` the ```separation()``` method uses the value passed to the ground_truth callback to store values for the yaw and position of each robot in the system. Once the dictionary containing these values has been populated, the ```separation()``` method checks whether the robots are below some minimum threshold distance; if true, the method iterates over all of the values for yaw and calculates the difference in heading to each of the robot's positions. Then, the list is sorted so the headings of robots are listed in cyclical order; in other words, all neighbors in the system relative to the current robot's heading will be listed next to one another in the list. Then, all consecutive pairs of the headings of bots are compared (i.e. heading[i] and heading[i+1] for all items of the list), and the maximum value is stored -- this value represents the largest "gap" in the system for which the current robot should travel. Then, the current robot rotates toward the midpoint of this angle so that its heading is aligned with the desired direction of movement to separate from neighbors. Note that although no forward movement occurs in the method, the implementation of the more general flocking behavior will ensure the robot will move forward, and separate from its neighbors, if there's room to do so.
#### (3) Alignment: Again, this method uses the yaw values from the ground_truth callback. The average yaw for all of the robots in the system is calculated using the stored values from the callback. Then, the difference in heading between the current robot and the average is calculated, and the robot continues to rotate until the average heading is achieved. Again, to compensate for changes that occur during this incremental process of turning, the average yaw of all robots is repeatedly calculated. 
#### Finally, to implement the more general flocking behavior, the ```flocking()``` method conditionally calls all of the methods once positional values have been updated by the ground_truth callback. While the node is running, minimum distance values are checked; when the minimum distance from a neighbor is too high, ```cohesion()``` is called, and when too low,  ```separation()```. The alignment behavior is consistently called, and after all of these methods' execution, the robot moves forward a small increment.

#### To achieve the above behavior, the program makes use of a LaserScan subscriber, a set of positional subscribers, and one publisher. 
#### The publisher is responsible for the movement of the robot, publishing messages for both ```move_forward()``` and ```rotate_in_place()```. A message is passed to tell the wheels to twist with the relevant values for velocity - linear x change for ```move_forward()```, angular z change for ```rotate_in_place()``` - for a calculated period of time. This time depends on the value for velocity, which is fixed, and the parameter ```distance```.
#### One subscriber listens to and processes the ouputs of the laser scanner. The robot only moves forward, with obstacles restricted to other mobile robots, so the bot simply stops (temporarily) when an object is directly in front. 
#### A set of subscriber is also used to listen to and process the outputs of ground_truth, which contains the positional information for all robots. Dictionaries are used to store the message information, which include x & y coordinates and quaternion information that's converted to euler for easier interpretation. The x & y coordinates are used to determine the distance of the current robot relative to neighbors, and the quaternion values are used to determine the yaw of the robots in the system. The use of this information is described in the above behaviors.

### Evaluation
#### The program works in creating flocking behavior in a multi-robot system. Two launch files are used to deploy systems in gazebo and stage, with 3 and 10 robots in the simulators respectively.
#### There are some limitations to the implementation of the behavior. It's relatively slow, and the process to implement the flocking behavior could be simplified by moving away from discretized actions and toward the methods of implementing each behavior discussed in class (i.e. with weighted actions). Vector arithmetic could also simplify the movement of the robots and likely improve on the efficiency of the system. There may also be some fine-tuning required with constants in the code to produce the most accurate/realistic flocking behavior in the system.